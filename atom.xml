<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QCFblog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-17T09:51:34.687Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>QianChaoFei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/01/17/call/"/>
    <id>http://yoursite.com/2017/01/17/call/</id>
    <published>2017-01-17T09:39:45.355Z</published>
    <updated>2017-01-17T09:51:34.687Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="JS中的call，-apply，bind方法"><a href="#JS中的call，-apply，bind方法" class="headerlink" title="JS中的call， apply，bind方法"></a>JS中的call， apply，bind方法</h2><p>在JavaScript中，call、apply和bind 是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向</p>
<h5 id="call、apply、bind方法的共同点和区别："><a href="#call、apply、bind方法的共同点和区别：" class="headerlink" title="call、apply、bind方法的共同点和区别："></a>call、apply、bind方法的共同点和区别：</h5><p>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；<br>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）；<br>apply 、 call 、bind 三者都可以利用后续参数传参；<br>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。<br><a id="more"></a></p>
<p>##一，call</p>
<h3 id="call"><a href="#call" class="headerlink" title="call(  )"></a>call(  )</h3><p>语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 定义：调用一个对象的一个方法，以另一个对象替换当前对象。</p>
<p>说明： call 方法可以用来代替另一个对象调用一个方法。<br>call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p>
<p>thisObj的取值有以下4种情况：<br>（1） 不传，或者传null,undefined， 函数中的this指向window对象<br>（2） 传递另一个函数的函数名，函数中的this指向这个函数的引用<br>（3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean<br>（4） 传递一个对象，函数中的this指向这个对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function a()&#123;   </div><div class="line">  console.log(this);   <span class="regexp">//</span>输出函数a中的this对象</div><div class="line">&#125;       </div><div class="line">function b()&#123;&#125;       </div><div class="line">var c=&#123;<span class="symbol">name:</span><span class="string">"call"</span>&#125;;    <span class="regexp">//</span>定义对象c  </div><div class="line">a.call();   <span class="regexp">//window</span></div><div class="line">a.call(null);   <span class="regexp">//window</span></div><div class="line">a.call(undefined);   <span class="regexp">//window</span></div><div class="line">a.call(<span class="number">1</span>);   <span class="regexp">//</span>Number</div><div class="line">a.call(<span class="string">''</span>);   <span class="regexp">//</span>String</div><div class="line">a.call(<span class="literal">true</span>);   <span class="regexp">//</span>Boolean</div><div class="line">a.call(b);   <span class="regexp">//function</span> b()&#123;&#125;</div><div class="line">a.call(c);   <span class="regexp">//</span>Object</div></pre></td></tr></table></figure>
<p>如果你不理解上面的，没关系，我们再来看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function first()&#123;   </div><div class="line">  this.name = function()&#123;   </div><div class="line">    console.log(&quot;我是first内的方法&quot;);   </div><div class="line">  &#125;   </div><div class="line"></div><div class="line">&#125;   </div><div class="line"></div><div class="line">function second()&#123; </div><div class="line"></div><div class="line">  first.call(this); //此行代码执行后，当前的this指向了first（也可以说second继承了second）,也就是说通过改变this的指向来让它在second里也能拥有first的方法  </div><div class="line">&#125;   </div><div class="line">var f=new second();   </div><div class="line">f.name();   //调用的是first内的方法，将first的name方法交给second使用</div></pre></td></tr></table></figure></p>
<p>下面举个例子来说明这个问题</p>
<h4 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function demo1()&#123;</div><div class="line">console.log(&quot;这是demo1&quot;);</div><div class="line">&#125;</div><div class="line">function demo2()&#123;</div><div class="line">console.log(&quot;这是demo2&quot;);</div><div class="line">&#125;</div><div class="line">demo1.call(demo2);</div><div class="line">结果：这是demo1</div></pre></td></tr></table></figure>
<p>这个例子是用demo1来替换demo2  </p>
<blockquote>
<p> 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</p>
</blockquote>
<h4 id="example2"><a href="#example2" class="headerlink" title="example2"></a>example2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function  Fruit()&#123;   </div><div class="line">  this.name =&quot; fruit&quot;;   </div><div class="line">  this.showName = function()&#123;   </div><div class="line">    console.log(this.name);   </div><div class="line">  &#125;   </div><div class="line">&#125;   </div><div class="line">function apple()&#123;   </div><div class="line">  this.name = &quot;apple&quot;;   </div><div class="line">&#125;   </div><div class="line">var  fruit = new  Fruit();   </div><div class="line">var apple = new appl();       </div><div class="line"> fruit.showName.call(apple);</div><div class="line">输出：apple</div></pre></td></tr></table></figure>
<p>根据上面的代码，我们可以看到apple里并没有showName方法，那为什么（this.name）的值是apple呢？</p>
<p>关键就在于最后一段代码（fruit.showName.call(apple)），意思是把fruit的方法放到apple上执行，也可以说，把fruit 的showName()方法放到 apple上来执行，所以this.name 应该是 apple。<br>简单点说就是apple通过this 调用了fruit 里面的showName方法</p>
<h4 id="example3-（继承）"><a href="#example3-（继承）" class="headerlink" title="example3 （继承）"></a>example3 （继承）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Animal(name)&#123;   </div><div class="line">  this.name=name;   </div><div class="line">  this.showName=function()&#123;   </div><div class="line">   console.log(this.name);   </div><div class="line"> &#125;   </div><div class="line">&#125;   </div><div class="line">function Dog(name)&#123;   </div><div class="line">  Animal.call(this,name);   </div><div class="line">&#125;   </div><div class="line">var dog=new Dog(&quot;Crazy dog&quot;);   </div><div class="line">dog.showName();</div><div class="line">输出：Crazy dog</div></pre></td></tr></table></figure>
<p>Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。</p>
<h2 id="二-apply"><a href="#二-apply" class="headerlink" title="二  , apply( )"></a>二  , apply( )</h2><p>语法：apply([thisObj[,argArray]])</p>
<p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</p>
<p>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<h4 id="call-和apply的区别"><a href="#call-和apply的区别" class="headerlink" title="call 和apply的区别"></a>call 和apply的区别</h4><p>一、call和apply相同点: </p>
<p>a） 产生的效果或作用完全相同；</p>
<p>b） 至少有一个参数；</p>
<p>c） 第一个参数必须有且是一个对象（Object）。</p>
<p>二、call和apply区别</p>
<p>传递参数的方式。用法上不同，主要是参数不完全同<br>三   实例说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;  </div><div class="line">this.name=name;  </div><div class="line">this.age=age;  </div><div class="line">this.money = 500;</div><div class="line">&#125; </div><div class="line"></div><div class="line">function myFun(money) &#123;        </div><div class="line">    alert(this.money);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var money = 100;</div><div class="line">myFun(money); </div><div class="line">//return 100;  //window.myFun(money); save to myFun(money);</div><div class="line">//这个时候this指向的是window对象，其实myFun函数和定义的var money = 100;都作为window对象子对象（即全局对象）</div><div class="line"></div><div class="line">myFun.apply(window,[]);  //save to window.myFun.apply(window,[]);  </div><div class="line">//return 100;  //同上</div><div class="line"></div><div class="line">myFun.apply(new Person(&apos;zhangsan&apos;,23),[]);  </div><div class="line">//return 500, 空数组作为参数，仅符合语法要求</div><div class="line">//这个时候myFun方法里面的this指向的是new Person(&apos;zhangsan&apos;,23)对象，二不是myFun类(函数)，故弹出500</div><div class="line"></div><div class="line">myFun.call(new Person(&apos;zhangsan&apos;,23),money,300,&apos;mycardId&apos;);  </div><div class="line">//return 500, 后面money,300和mycardId是参数列表作为参数，一一列出</div><div class="line">//这个时候myFun方法里面的this指向的是new Person(&apos;zhangsan&apos;,23)对象，二不是myFun类(函数)，故弹出500</div></pre></td></tr></table></figure>
<h2 id="三、bind"><a href="#三、bind" class="headerlink" title="三、bind"></a>三、bind</h2><p>bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）<br>bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。</p>
<p>　　MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数</p>
<blockquote>
<p>  注意：bind方法的返回值是函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var bar=function()&#123;   </div><div class="line">  console.log(this.x);   </div><div class="line">&#125;</div><div class="line">var foo = &#123; </div><div class="line">     x:3   </div><div class="line">&#125;   </div><div class="line">bar();  </div><div class="line">bar.bind(foo)();</div><div class="line"> /*或*/</div><div class="line">var func = bar.bind(foo);   </div><div class="line">func();</div><div class="line">输出：</div><div class="line">undefined</div><div class="line">3</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;JS中的call，-apply，bind方法&quot;&gt;&lt;a href=&quot;#JS中的call，-apply，bind方法&quot; class=&quot;headerlink&quot; title=&quot;JS中的call， apply，bind方法&quot;&gt;&lt;/a&gt;JS中的call， apply，bind方法&lt;/h2&gt;&lt;p&gt;在JavaScript中，call、apply和bind 是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向&lt;/p&gt;
&lt;h5 id=&quot;call、apply、bind方法的共同点和区别：&quot;&gt;&lt;a href=&quot;#call、apply、bind方法的共同点和区别：&quot; class=&quot;headerlink&quot; title=&quot;call、apply、bind方法的共同点和区别：&quot;&gt;&lt;/a&gt;call、apply、bind方法的共同点和区别：&lt;/h5&gt;&lt;p&gt;apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；&lt;br&gt;apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）；&lt;br&gt;apply 、 call 、bind 三者都可以利用后续参数传参；&lt;br&gt;bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/01/07/git/"/>
    <id>http://yoursite.com/2017/01/07/git/</id>
    <published>2017-01-07T03:53:10.125Z</published>
    <updated>2017-01-17T10:02:31.604Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="Git-config全局配置"><a href="#Git-config全局配置" class="headerlink" title=" Git config全局配置"></a> Git config全局配置</h2><p>Git config全局配置<br><strong>git:提交前的强制检查各个项目用户邮箱设置</strong></p>
<blockquote>
<p><strong>git</strong>   <strong>强制</strong>   <strong>邮箱</strong><br><a id="more"></a></p>
</blockquote>
<p><strong>保证提交日志的准确性</strong><br>在提交时，user.name, user.email会进入日志。这些信息，是追踪代码变更的关键。<br>为了保证这些信息的准确性，在push时，强制检查，如果user.name和user.email信息不正确，则拒绝push。</p>
<p><strong>全局配置</strong><br>如果我们工作中只涉及一个git服务器，用一个全局配置就可以搞定了：</p>
<h3 id="全局配置代码"><a href="#全局配置代码" class="headerlink" title="全局配置代码"></a>全局配置代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --<span class="keyword">global</span> user.name <span class="string">"qweee.com"</span>git config --<span class="keyword">global</span> user.email <span class="string">"my email @qq.com"</span></div></pre></td></tr></table></figure>
<p><strong>工作在多个git项目</strong><br>但是我们可能同时工作在多个项目中，公司内部用自有的git管理项目，我们在github上还有自己的项目。<br>对于使用不同的用户身份，需要设置不用的sshkey，具体的配置可以看这里：[多个sshkey配置][1]<br>这个时候，对于user.name和user.email我们不能采用全局的配置。而是要对各个项目单独配置。<br><strong>项目配置</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config user.name <span class="string">"QQ号@.com"</span></div><div class="line">git config user.email <span class="string">"QQ号@.com"</span></div></pre></td></tr></table></figure></p>
<p><strong>忘了做配置</strong><br>对于项目配置，有时我们会忘记在git init或者git clone之后，配置user.name以及user.email。<br>如果有全局配置，则使用全局配置。如果没全局配置，报错。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[qcf@ssrc test]$ git ci -a -m <span class="string">'commit for testing no user.name empty'</span> *** Please tell me who you are. Run git config --<span class="keyword">global</span> user.email <span class="string">"you@example.com"</span>git config --<span class="keyword">global</span> user.name <span class="string">"Your Name"</span> to set your account<span class="string">'s default identity. Omit --global to set the identity only in this repository. fatal: empty ident name (for &lt;qq.com&gt;) not allowed</span></div></pre></td></tr></table></figure></p>
<p>报错能够及时纠正我们的错误，最糟糕的情况是：</p>
<blockquote>
<ul>
<li><strong>没有项目单独配置，提交的时候，自动采用全局配置。在发现问题之后需要对日志进行修复。</strong></li>
</ul>
</blockquote>
<p><strong>强制检查</strong></p>
<p>强制检查可以在服务器端push的时候检查，也可以在客户端进行检查，这里介绍使用`pre-commit钩子进行检查。<br>全局钩子的配置，可以参见这里: git全局钩子<br><strong>如何确定正确配置</strong></p>
<ul>
<li>确定没有全局配置</li>
<li>确定有项目配置</li>
</ul>
<p><strong>pre-commit hook</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">global_email=$(git config --<span class="keyword">global</span> user.email)global_name=$(git config --<span class="keyword">global</span> user.name) repository_email=$(git config user.email)repository_name=$(git config user.name) <span class="keyword">if</span> [ -z <span class="string">"$repository_email"</span> ] || [ -z <span class="string">"$repository_name"</span> ] || [ -n <span class="string">"$global_email"</span> ] || [ -n <span class="string">"$global_name"</span> ]; then <span class="comment"># user.email is empty echo "ERROR: [pre-commit hook] Aborting commit because user.email or user.name is missing. Configure them for this repository. Make sure not to configure globally." exit 1else # user.email is not empty exit 0fi</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;Git-config全局配置&quot;&gt;&lt;a href=&quot;#Git-config全局配置&quot; class=&quot;headerlink&quot; title=&quot; Git config全局配置&quot;&gt;&lt;/a&gt; Git config全局配置&lt;/h2&gt;&lt;p&gt;Git config全局配置&lt;br&gt;&lt;strong&gt;git:提交前的强制检查各个项目用户邮箱设置&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;git&lt;/strong&gt;   &lt;strong&gt;强制&lt;/strong&gt;   &lt;strong&gt;邮箱&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
